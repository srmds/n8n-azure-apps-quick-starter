parameters:
  - name: azureSubscription
    type: string
    default: 'Azure Subscription'
  - name: resourceGroupName
    type: string
  - name: location
    type: string
  - name: environmentName
    type: string
  - name: containerAppName
    type: string
  - name: postgresServerName
    type: string
  - name: postgresAdminUsername
    type: string
  - name: postgresAdminPassword
    type: string
    default: ''
  - name: domainName
    type: string
  - name: templateFilePath
    type: string
    default: 'infrastructure/main.bicep'
  - name: buildId
    type: string
  - name: dryRun
    type: boolean
    default: false
  - name: containerCpu
    type: string
    default: '0.5'
  - name: containerMemory
    type: string
    default: '1Gi'
  - name: minReplicas
    type: number
    default: 0
  - name: maxReplicas
    type: number
    default: 5
  - name: keyVaultName
    type: string
    default: ''
steps:
  - task: AzureCLI@2
    displayName: 'Generate Random Password'
    inputs:
      azureSubscription: ${{ parameters.azureSubscription }}
      scriptType: bash
      scriptLocation: inlineScript
      inlineScript: |
        # Generate a secure random password
        RANDOM_PASSWORD=$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-25)
        echo "Generated random password: ${RANDOM_PASSWORD:0:8}..."
        
        # Set as pipeline variable for use in subsequent tasks
        echo "##vso[task.setvariable variable=generatedPassword;isSecret=true]$RANDOM_PASSWORD"
        
        echo "Password generated successfully and stored as secret variable"

  - task: AzureCLI@2
    displayName: 'Store Password in Key Vault'
    condition: and(ne('${{ parameters.keyVaultName }}', ''), eq(${{ parameters.dryRun }}, false))
    inputs:
      azureSubscription: ${{ parameters.azureSubscription }}
      scriptType: bash
      scriptLocation: inlineScript
      inlineScript: |
        # Store the generated password in Key Vault
        echo "Storing password in Key Vault '${{ parameters.keyVaultName }}'..."
        
        # Check if Key Vault exists
        if az keyvault show --name ${{ parameters.keyVaultName }} --resource-group ${{ parameters.resourceGroupName }} >/dev/null 2>&1; then
          echo "Key Vault exists, storing secret..."
          
          # Store the secret in Key Vault
          az keyvault secret set \
            --vault-name ${{ parameters.keyVaultName }} \
            --name "postgres-password-${{ parameters.environmentName }}" \
            --value "$(generatedPassword)" \
            --output none
            
          echo "✅ Password stored successfully in Key Vault"
          
          # Get the secret URL for reference
          SECRET_URL=$(az keyvault secret show \
            --vault-name ${{ parameters.keyVaultName }} \
            --name "postgres-password-${{ parameters.environmentName }}" \
            --query id \
            --output tsv)
          
          echo "Secret URL: $SECRET_URL"
          
        else
          echo "❌ Key Vault '${{ parameters.keyVaultName }}' not found, creating it..."
          
          # Create Key Vault with soft delete enabled
          az keyvault create \
            --name ${{ parameters.keyVaultName }} \
            --resource-group ${{ parameters.resourceGroupName }} \
            --location ${{ parameters.location }} \
            --enable-soft-delete true \
            --soft-delete-retention-in-days 7 \
            --enable-purge-protection false \
            --sku standard \
            --output none
            
          echo "✅ Key Vault '${{ parameters.keyVaultName }}' created successfully"
          
          # Store the secret
          az keyvault secret set \
            --vault-name ${{ parameters.keyVaultName }} \
            --name "postgres-password-${{ parameters.environmentName }}" \
            --value "$(generatedPassword)" \
            --output none
            
          echo "✅ Password stored successfully in Key Vault"
          
          # Get the secret URL for reference
          SECRET_URL=$(az keyvault secret show \
            --vault-name ${{ parameters.keyVaultName }} \
            --name "postgres-password-${{ parameters.environmentName }}" \
            --query id \
            --output tsv)
          
          echo "Secret URL: $SECRET_URL"
        fi

  - task: AzureCLI@2
    displayName: 'Build Bicep files'
    inputs:
      azureSubscription: ${{ parameters.azureSubscription }}
      scriptType: bash
      scriptLocation: inlineScript
      inlineScript: |
        az --version && az bicep upgrade
        az bicep build --file ${{ parameters.templateFilePath }}
  - task: AzureCLI@2
    displayName: 'Validate Bicep files'
    inputs:
      azureSubscription: ${{ parameters.azureSubscription }}
      scriptType: bash
      scriptLocation: inlineScript
      inlineScript: |
        az deployment group validate \
        --resource-group ${{ parameters.resourceGroupName }} \
        --template-file ${{ parameters.templateFilePath }} \
        --parameters resourceGroupName='${{ parameters.resourceGroupName }}' location='${{ parameters.location }}' environmentName='${{ parameters.environmentName }}' containerAppName='${{ parameters.containerAppName }}' postgresServerName='${{ parameters.postgresServerName }}' postgresAdminUsername='${{ parameters.postgresAdminUsername }}' postgresAdminPassword='$(generatedPassword)' domainName='${{ parameters.domainName }}' containerCpu='${{ parameters.containerCpu }}' containerMemory='${{ parameters.containerMemory }}' minReplicas=${{ parameters.minReplicas }} maxReplicas=${{ parameters.maxReplicas }} \
        --name ${{ parameters.buildId }}
  - task: AzureCLI@2
    displayName: 'Dry-run Bicep files (what-if on resource group level)'
    inputs:
      azureSubscription: ${{ parameters.azureSubscription }}
      scriptType: bash
      scriptLocation: inlineScript
      inlineScript: |
        az deployment group what-if \
        --resource-group ${{ parameters.resourceGroupName }} \
        --parameters resourceGroupName='${{ parameters.resourceGroupName }}' location='${{ parameters.location }}' environmentName='${{ parameters.environmentName }}' containerAppName='${{ parameters.containerAppName }}' postgresServerName='${{ parameters.postgresServerName }}' postgresAdminUsername='${{ parameters.postgresAdminUsername }}' postgresAdminPassword='$(generatedPassword)' domainName='${{ parameters.domainName }}' containerCpu='${{ parameters.containerCpu }}' containerMemory='${{ parameters.containerMemory }}' minReplicas=${{ parameters.minReplicas }} maxReplicas=${{ parameters.maxReplicas }} \
        --template-file ${{ parameters.templateFilePath }} \
        --result-format FullResourcePayloads
  - task: AzureCLI@2
    displayName: 'Provision n8n infrastructure'
    condition: eq(${{ parameters.dryRun }}, false)
    inputs:
      azureSubscription: ${{ parameters.azureSubscription }}
      scriptType: bash
      scriptLocation: inlineScript
      inlineScript: |
        az deployment group create \
        --resource-group ${{ parameters.resourceGroupName }} \
        --mode 'Incremental' \
        --parameters resourceGroupName='${{ parameters.resourceGroupName }}' location='${{ parameters.location }}' environmentName='${{ parameters.environmentName }}' containerAppName='${{ parameters.containerAppName }}' postgresServerName='${{ parameters.postgresServerName }}' postgresAdminUsername='${{ parameters.postgresAdminUsername }}' postgresAdminPassword='$(generatedPassword)' domainName='${{ parameters.domainName }}' containerCpu='${{ parameters.containerCpu }}' containerMemory='${{ parameters.containerMemory }}' minReplicas=${{ parameters.minReplicas }} maxReplicas=${{ parameters.maxReplicas }} \
        --template-file ${{ parameters.templateFilePath }} \
        --rollback-on-error
  - task: AzureCLI@2
    displayName: 'Get Deployment Outputs'
    condition: eq(${{ parameters.dryRun }}, false)
    inputs:
      azureSubscription: ${{ parameters.azureSubscription }}
      scriptType: bash
      scriptLocation: inlineScript
      inlineScript: |
        # Get deployment outputs
        DEPLOYMENT_OUTPUT=$(az deployment group show \
          --resource-group ${{ parameters.resourceGroupName }} \
          --name ${{ parameters.buildId }} \
          --query properties.outputs \
          --output json)
        
        echo "##vso[task.setvariable variable=containerAppUrl;isOutput=true]$(echo $DEPLOYMENT_OUTPUT | jq -r '.containerAppUrl.value')"
        echo "##vso[task.setvariable variable=postgresServerFqdn;isOutput=true]$(echo $DEPLOYMENT_OUTPUT | jq -r '.postgresServerFqdn.value')"
        
        echo "Deployment completed successfully!"
        echo "Container App URL: $(echo $DEPLOYMENT_OUTPUT | jq -r '.containerAppUrl.value')"
        echo "PostgreSQL Server: $(echo $DEPLOYMENT_OUTPUT | jq -r '.postgresServerFqdn.value')"
        echo "Generated Password: ${generatedPassword:0:8}..."
        
        # Show Key Vault info if used
        if [ ! -z "${{ parameters.keyVaultName }}" ]; then
          echo "Password stored in Key Vault: ${{ parameters.keyVaultName }}"
          echo "Secret name: postgres-password-${{ parameters.environmentName }}"
        fi 